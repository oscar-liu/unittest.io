# unittest.io

新建一个fn.py文件,准备一些待测试的方法
####fn.py

    #待测试的方法函数

    def add(a, b):
        return a+b

    def minus(a, b):
        return a-b

    def multi(a, b):
        return a*b

    def divide(a, b):
        return a/b

再建一个测试文件test_fn.py
###test_fn.py
    # -*- coding: utf-8 -*-
    import unittest
    from fn import * #导入所有待测试方法

    #定义测试类
    class TestFn(unittest.TestCase):

        def test_add(self):
            self.assertEqual(3, add(1,2))
    
        def test_minus(self):
            self.assertEqual(6, minus(7,1))

        def test_multi(self):
            self.assertEqual(6, multi(2,3))

        def test_divide(self):
            self.assertEqual(2,divide(6,3))
               self.assertEqual(2,divide(5,2))

    if __name__ == '__main__':
        unittest.main()


### 测试结果：

![](http://webliu.cn/content/images/2017/12/QQ20171216-103600-2x.png)

可以看到，执行了4次，及执行时间，
成功了3次，失败了一次，失败的原因也给出来了， 2 != 2.5，divide方法。


### 测试结果说明：

  - 在第一行给出了每一个用例执行的结果的标识，成功是 .，失败是 F，出错是 E，跳过是 S。从上面也可以看出，测试的执行跟方法的顺序没有关系，test_divide写在了第4个，但是却是第2个执行的。

  - 每个测试方法均以 test 开头，否则是不被unittest识别的。

在unittest.main()中加 verbosity 参数可以控制输出的错误报告的详细程度，默认是 1，如果设为 0，则不输出每一用例的执行结果，即没有上面的结果中的第1行；如果设为 2，则输出详细的执行结果：

如图示，verbosity =2
![](http://webliu.cn/content/images/2017/12/QQ20171216-103955-2x.png)

 到这里我们就已经完成一个简单的单元测试案例了。

### TestSuite

以上有几个问题：

  - 我们如何控制正常的测试用例的执行顺序(实际项目中会有依赖关系，必须严格遵守先后执行顺序）
  - 现在我们只有一个测试文件，直接执行文件即可，如果有多个测试文件，需要进行组织，总不可能一个文件一个的执行。

回溯一下上面关于TestSuite的概念理解。

举个粟子：

##### test_suite.py

    # -*- coding: utf-8 -*-

    import unittest
    from test_fn import TestFn

    if __name__ == '__main__':
        #实例化TestSuite
        suite = unittest.TestSuite()

        #将测试方法按照顺序加入到list
        tests = [ TestFn('test_add'), TestFn('test_minus'), TestFn('test_multi'), TestFn('test_divide') ]
        #添加到TestSuite中
        suite.addTests(tests)

        runner = unittest.TextTestRunner(verbosity=2)
        runner.run(suite)

执行输出结果：

![](http://webliu.cn/content/images/2017/12/TestSuite.png)
可以看到，传入了4个TestCase到列表中，执行的时候也是按照添加的顺序来执行的。

#### test_suite2.py
    # -*- coding: utf-8 -*-

    import unittest
    from test_fn import TestFn

    if __name__ == '__main__':
        #实例化TestSuite
        suite = unittest.TestSuite()

        #直接用addTest方法添加单个TestCase
        suite.addTest(TestFn('test_add'))

        #用addTest + TestLoader

        #loadTestsFromName(), 传入'模块名,TestCase名'
        suite.addTests(unittest.TestLoader().loadTestsFromName('test_fn.TestFn'))

        runner = unittest.TextTestRunner(verbosity=2)
        runner.run(suite)

![](http://webliu.cn/content/images/2017/12/test_suite2.png)


#### test_suite3.py
利用loadTestsFromNames加载多个到测试列表中
示例：先在test_fn.py中再复制一个TestFn2的类，里面再写n个TestCase。

    # -*- coding: utf-8 -*-

    import unittest
    from test_fn import TestFn,TestFn2

    if __name__ == '__main__':
        #实例化TestSuite
        suite = unittest.TestSuite()

        #直接用addTest方法添加单个TestCase
        suite.addTest(TestFn('test_add'))

        #用addTest + TestLoader

        #loadTestsFromName(), 传入'模块名,TestCase名'

        # loadTestsFromNames加入list中
        suite.addTests(unittest.TestLoader().loadTestsFromNames(['test_fn.TestFn','test_fn.TestFn2']))


        runner = unittest.TextTestRunner(verbosity=2)
        runner.run(suite)

输出结果：
![](http://webliu.cn/content/images/2017/12/test_suite3.png)

### 将结果输出到文件/html

#### test_suite_file.py

    # -*- coding: utf-8 -*-

    import unittest
    from test_fn import TestFn

    if __name__ == '__main__':
        #实例化TestSuite
        suite = unittest.TestSuite()
        suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestFn))

        #将测试结果输出到文件中
        with open('UnittestTextReport.txt', 'a') as f:
            runner = unittest.TextTestRunner(stream=f,verbosity=2)
            runner.run(suite)




#### test_suite_html.py

HTMLTestRunner.py文件，我的环境是python3，网上下载的这个让你说的需要稍微进行修改。

文件地址：

https://github.com/oscar-liu/unittest.io/blob/master/HTMLTestRunner.py


    # -*- coding: utf-8 -*-

    import unittest
    from test_fn import TestFn
    from HTMLTestRunner import HTMLTestRunner

    if __name__ == '__main__':
        #实例化TestSuite
        suite = unittest.TestSuite()
        suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestFn))

        #将测试结果输出到文件中
        with open('HTMLReport.html', 'wb') as f:
            runner = HTMLTestRunner(stream=f,
                                    title='MathFunc Test Report',
                                    description='generated by HTMLTestRunner.',
                                    verbosity=2
                                    )
            runner.run(suite)



### test fixture之setUp() tearDown()

上面是最简单的一个单元测试案例，当某些测试需要准备一些执行环境，以及测试完需要关闭清理环境。比如，执行前连接数据库，完成后断开等...

这里介绍了解一下test fixture。

##### test_fn_fixture.py
将原来的test_fn文件修改一下成test_fn_fixture.py文件。

添加了 setUp() 和 tearDown() 两个方法（其实是重写了TestCase的这两个方法），这两个方法在每个测试方法执行前以及执行后执行一次，setUp用来为测试准备环境，tearDown用来清理环境，已备之后的测试。

    def setUp(self):
        print("这里是执行测试前的准备")

    def tearDown(self):
        print("这里是测试完成后")

![](http://webliu.cn/content/images/2017/12/test_fn_fixture.png)

可以看到setUp和tearDown在每次执行case前后都执行了一次。

如果想要在所有case执行之前准备一次环境，并在所有case执行结束之后再清理环境，我们可以用 setUpClass() 与 tearDownClass():

    @classmethod
    def setUpClass(cls):
        print("这里是执行测试前的准备")

    @classmethod
    def tearDownClass(cls):
        print("这里是测试完成后")

![](http://webliu.cn/content/images/2017/12/test_fn_fixture2.png)
可以看到setUpClass以及tearDownClass均只执行了一次。

